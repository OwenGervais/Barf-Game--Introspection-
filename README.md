[Base Game]
Our game was a GDW weekly project for a short narrative game. The game is intended to have branching paths which can lead to 3 endings. For this, our group decided to make a sort of PSA interactive game, which focuses on themes such as substance abuse and peer pressure. The playable character is a victim of being pressured by a close friend to take drugs. The player walks around and can interact with conflicting paths, on choosing to stay with his friend, and indulging in this unhealthy lifestyle, or to leave, having to walk away from this relationship.

Currently, there are only 2 stages, with not much challenge or complexity, but there are intending to be more, with the “bad ending” options to have a friend be easy access, while the “good ending” options be a challenge or a long journey. Depending on the decisions the player made, they will face different endings, depending on the ratio.

[Lighting]
Simple Diffuse:
To create a simple diffuse shader, we use the Lambertian lighting model which works on the principle that light will scatter equally in all directions regardless of the viewing angle. The formula for the Lambert reflection is the cosine of the angle of incidence times the intensity of the light source.

In order to achieve this in ShaderLab, we first take the dot product of the world-space normal and the main light direction. Since both of these have a magnitude of one, this is functionally identical to taking the cosine of the angle of incidence. We then multiply this by the color of the object and the color of the main light to simulate the reflected light.

Ambient Diffuse:
Creating an ambient diffuse shader is as simple as using the SampleSH function on the surface normal to calculate the approximate ambient light and adding that to the diffuse shader.

Simple Specular:
As opposed to the simple diffuse shader with the Lambertian model, the specular shader uses the Blinn-Phong lighting model which essentially does the opposite--Blinn-Phong takes into account the viewing angle to calculate the shininess of the object.

To use this, we first use the reflect function on the light direction by our normal in world space and take the dot product between that and the view direction. As mentioned before in the Lambert reflection, the cosine of the angle of incidence predicts the intensity of the light. This is essentially the same concept, except we’re taking in the viewing angle instead, meaning this intensity will be dynamic as we move around the object. We then add this to the same models from before (our specific script has extra variables for shininess and shine factor which are simple exponential and multiplicative modifiers on the Blinn-Phong model) and we have our simple specular shader.

Toon Ramp:
The toon shader is not particularly complicated. Very similar to the Lambertian model, we take in the dot product of the world space normal and main light direction. The only change here is that we use this output as an x-coordinate lookup for a stepped ramp texture. This is trivial and the explanation is virtually the exact same as the simple diffuse shader--using the dot product and cosine to calculate the light intensity.

Flat Shader:
Flat shading is when you give each triangle’s normal (every vector) one color. This results in a collection of polygons giving the object a low-poly faceted look. This also is less computationally expensive due to its simplicity. 

In order to achieve this look in ShaderLab we first needed to compute the face normal. To do this we used the ddx and ddy functions to compute the derivative of the World Position along 2 of the edges of the triangle. After this we then used the cross product of the 2 edges to acquire the face normal. After finding the face normal we use the fragment shader to compute the lighting of the object, this ensures that the entire face of the polygon (triangle) is uniformly shaded; uniform shading give the triangle a monocolored flat look, a bunch of these give the object the low-poly look


[Color Grading]
To implement color grading, we used a Global Volume and modified the world LUT in post-processing. This LUT is 2048x64 and was generated by changing the HSV of a screenshot of the game with the LUT over it, saving that LUT, and reimporting into Unity.

Using the color filters, they were used to symbolize the type of ending the player received. During the final room, the scripts detect what the ending is, and activate the corresponding filter. Each filter uses a Volume component to change the Color Lookup Contribution, over time to ease into the filter. 

[Shaders and Effects]
Rim Light:
Rim light is when light appears to be glancing off the edge/edges of an object. This creates a bright outline (“rim”) around the parts that are facing away (and are on the outer part of the object) from where the camera is positioned.

To create this effect in ShaderLab we have to determine where the object is in world space in regards to the camera. To do this we first had to convert the object's position to clip space for rendering then convert the normals of the object into world space. Afterwards, we had to find the camera's position in world space and find the camera's viewing direction. Upon doing this we have enough information to calculate the dot product with the object and the camera (view direction in world space and the object's normals in world space). This allows us to then create a create a rim around the object in relation to where the camera is looking at it by inverting and clamping the saturation of the rims position factor (this makes the color appear the most along edges of the object and not appear where the objects normals are facing the camera)

The main use of this shader was to indicate when a player is able to interact with an NPC or item. When a player is nearby, and looks at an interactable, it will swap materials, keeping the same texture and color, but changing if they have the rim light effect.

Distortion:
This shader effect was referenced by the Youtuber, Digvijaysinh Gohil. This effect distorts the screen to make a visual illusion of being underwater, or a sense of nausea and dizziness. To make this shader, it utilizes by applying the shader to the full screen. To use a full screen shader, you can make an instance on the game’s renderer and apply the shader there. The shader is made by using a Simple Noise, and offsetting the noise by time passed. It is also put with the Sine function to create the waves on the Noise. The noise is then lerped with a standard UV mapping, as it is just going across the screen, to then go into a Scene Color function to make it seem transparent while distorting the surroundings.

This is not fully integrated into the gameplay mechanics, but it is intended to be added to future stage challenges.

Mirror:
This shader was referenced from the Youtuber, Nerd Head. To make this, it utilizes a custom render texture that references a camera to mimic a reflection. The camera acts as basically a screen, but it is pointed in the direction of the player so it acts as a mirror. The material is then set to an unlit shader to remove any unnecessary effects.
